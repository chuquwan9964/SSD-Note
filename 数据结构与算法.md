## 数据结构

#### 稀疏数组

​	当一个二维数组或多维数组中的值大部分为相同值，少部分为不同值时，要想保存此数组，可以优化一下，使用稀疏数组

```
package com.chuquwan.parsearray;

import java.awt.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * 数组转成稀疏数组
 */
public class ArrayToSparseArray {

    public static void main(String[] args) {
        int[][] arr = new int[11][11];
        arr[5][5] = 1;
        arr[6][6] = 2;

        for (int[] a : arr) {
            System.out.println(Arrays.toString(a));
        }

        System.out.println("----------------------------------------");

        int[][] sparseArray = arrayToSparseArray(arr);
        for (int[] a : sparseArray) {
            System.out.println(Arrays.toString(a));
        }

        System.out.println("----------------------------------------");

        int[][] reduction = reductionToArray(sparseArray);
        for (int[] a : reduction) {
            System.out.println(Arrays.toString(a));
        }


    }
	
	//正常数组转为稀疏数组
    public static int[][] arrayToSparseArray(int[][] srcArray) {
        if (srcArray == null || srcArray.length == 0)
            return null;

        List<Node> effectiveData = new ArrayList<>();

        int validDataCount = 0; //有效数据的个数
        for (int i = 0; i < srcArray.length; i++) {
            for (int j = 0; j < srcArray[i].length; j++) {
                if (srcArray[i][j] != 0) {
                    validDataCount++;
                    effectiveData.add(new Node(i, j, srcArray[i][j]));
                }
            }
        }

        int[][] ret = new int[validDataCount + 1][3];

        ret[0][0] = srcArray.length;
        ret[0][1] = srcArray.length;
        ret[0][2] = validDataCount;

        int currentRow = 1;
        for (Node node : effectiveData) {
            ret[currentRow][0] = node.x;
            ret[currentRow][1] = node.y;
            ret[currentRow][2] = node.data;
            currentRow++;
        }

        return ret;
    }

	//还原成正常数组
    public static int[][] reductionToArray(int[][] sparseArray) {
        if (sparseArray == null || sparseArray.length == 0)
            return null;

        int len = sparseArray[0][0];

        int[][] ret = new int[len][len];

        for (int i = 1; i < sparseArray.length; i++) {
            int x = sparseArray[i][0];
            int y = sparseArray[i][1];
            int data = sparseArray[i][2];

            ret[x][y] = data;
        }

        return ret;
    }

    private static final class Node {
        int x;
        int y;
        int data;

        public Node(int x, int y, int data) {
            this.x = x;
            this.y = y;
            this.data = data;
        }
    }
}

```



#### 队列(Queue)

​	何谓列表有序?

​		有序指的是列表中的数据的插入顺序和遍历顺序一样

​		而不是里面的值是有序的

​	队列是一个有序列表，可以用数组或链表实现

​	先进先出



##### 普通队列

​	使用数组实现

```
package com.chuquwan.queue;

import java.util.Arrays;
import java.util.Objects;

/**
 * 队列
 * 普通队列
 * 使用数组实现
 */
public class Queue<T> {
    //队列头部，本数+1就是下一个要取出的索引
    private int front = -1;
    //代表当前队列尾元素的索引,本数+1就是下一个要存入的索引
    private int rear = -1;

    private Object[] data;

    private final int MAX_SIZE;

    private int len;

    public Queue(int max_size) {
        this.MAX_SIZE = max_size;
        data = new Object[MAX_SIZE];
    }

    public Queue() {
        this(64);
    }

    public void push(T t) {
        if (t == null)
            throw new NullPointerException("arg is null");
        if (isFull()) {
            System.out.println("队列满");
            return;
        }
        data[++rear] = t;
        len++;
    }

    public T pop() {
        if (isEmpty()) {
            return null;
        }
        T t;
        t = (T) data[++front];
        len--;
        return t;
    }

    public int length() {
        return len;
    }

    public boolean isFull() {
        return rear == MAX_SIZE - 1;
    }

    public boolean isEmpty() {
        return rear == front;
    }

    public static void main(String[] args) {
        class User {
            String name;

            public User(String name) {
                this.name = name;
            }

            @Override
            public String toString() {
                return name;
            }
        }

        Queue<User> q = new Queue<>();
        User sjh = new User("sjh");
        User sjh1 = new User("sjh1");
        User sjh2 = new User("sjh2");
        User sjh3 = new User("sjh3");

        q.push(sjh);
        q.push(sjh1);
        q.push(sjh2);

        q.push(sjh3);

        for (int i = 0; i < 4; i++) {
            System.out.println(q.pop().toString());
        }

    }
}

```



##### 环形队列

​	跟老师写的不一样，我现在累了，不想解释了

​	利用一个len属性判断队列 是否为空或者满，标准的是front==rear就是空，(rear+1)%MAX_SIZE==front就是满了，但是标准的浪费了一个存储空间，也就是说容量为5的队列，只能存4个数，因为只有这样才能保证正确判断队列是满还是空，如果不牺牲这个存储空间的话，那么空和满的条件都是front==rear，就无法判断了

​	我利用一个len属性判断，不需要牺牲一个存储空间，不知道我这个方法有没有什么错误，暂时没有

```
package com.chuquwan.queue;

import java.util.Arrays;
import java.util.Scanner;

/**
 * 环形队列
 * 解决了队列空间浪费的问题
 */
public class CircleQueue<T> {

    private Object[] data;
    //队列头部,表示下一个要取出的元素的索引,初始值为0
    private int front;
    //代表当前队列尾元素的索引,表示下一个要存入的元素索引,初始值为0
    private int rear;
    private final int MAX_SIZE;
    private int len;	//利用此len来判断是否为空或者满

    public CircleQueue(int maxSize) {
        this.MAX_SIZE = maxSize;
        this.front = 0;
        this.rear = 0;
        this.data = new Object[MAX_SIZE];
    }

    public boolean isEmpty() {
        return len == 0;
    }

    public boolean isFull() {
        return len == MAX_SIZE;
    }

    public void push(T t) {
        if (t == null)
            return;
        if (isFull()) {
            System.out.println("数组满了");
            return;
        }
        data[rear] = t;
        rear = (rear + 1) % MAX_SIZE;
        len++;
    }

    public T pop() {
        if (isEmpty()) {
            System.out.println("空");
            return null;
        }

        T t = (T) data[front];
        front = (front + 1) % MAX_SIZE;
        len--;
        return t;
    }

    public void showQueue() {
        System.out.println(Arrays.toString(data));
    }

    public static void main(String[] args) {
        //测试一把
        System.out.println("测试数组模拟环形队列的案例~~~");

        // 创建一个环形队列
        CircleQueue<Integer> queue = new CircleQueue(5); //说明设置4, 其队列的有效数据最大是3
        char key = ' '; // 接收用户输入
        Scanner scanner = new Scanner(System.in);//
        boolean loop = true;
        // 输出一个菜单
        while (loop) {
            System.out.println("s(show): 显示队列");
            System.out.println("e(exit): 退出程序");
            System.out.println("a(add): 添加数据到队列");
            System.out.println("g(get): 从队列取出数据");
            System.out.println("h(head): 查看队列头的数据");
            key = scanner.next().charAt(0);// 接收一个字符
            switch (key) {
                case 's':
                    queue.showQueue();
                    break;
                case 'a':
                    System.out.println("输出一个数");
                    int value = scanner.nextInt();
                    queue.push(value);
                    break;
                case 'g': // 取出数据
                    try {
                        int res = queue.pop();
                        System.out.printf("取出的数据是%d\n", res);
                    } catch (Exception e) {
                        // TODO: handle exception
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'h': // 查看队列头的数据
                    try {
                        int res = queue.headQueue();
                        System.out.printf("队列头的数据是%d\n", res);
                    } catch (Exception e) {
                        // TODO: handle exception
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'e': // 退出
                    scanner.close();
                    loop = false;
                    break;
                default:
                    break;
            }
        }
        System.out.println("程序退出~~");
    }

    private T headQueue() {
        if (!isEmpty())
            return (T) data[front];
        return null;
    }
}

```



#### LinkedList

​	为什么要有头结点呢?为了操作方便

##### 单链表

```
 class SingleLinkedList {
 	//单链表的头结点
    private HeroNode head = new HeroNode();
    //单链表的结点类型
     static final class HeroNode {
            private int no;
            private String name;
            private String nickName;
            private HeroNode next;

            public HeroNode(int no, String name, String nickName) {
                this.no = no;
                this.name = name;
                this.nickName = nickName;
            }

            public HeroNode() {
            }

            @Override
            public String toString() {
                return "HeroNode{" +
                        "no=" + no +
                        ", name='" + name + '\'' +
                        ", nickName='" + nickName + '\'' +
                        '}';
            }

            @Override
            protected void finalize() throws Throwable {
                System.out.println(this + "被回收了");
            }
        }
    }
```

###### 插入

```
	/**
     * 加入一个结点但不排序,就是在链表最后插入一个结点
     *
     * @param node
     */
    public void add(HeroNode node) {
        Objects.requireNonNull(node);
        HeroNode temp = head;
        while (true) {
            if (temp.next == null)
                break;
            temp = temp.next;
        }

        temp.next = node;
    }
    
     public void addAndSort(HeroNode node) {
        Objects.requireNonNull(node);
        HeroNode temp = head;
        while (true) {
            if (temp.next == null)
                break;
            if (temp.next.no == node.no) {
                System.out.println("座位被占了...");
                return;
            }
            if (temp.next.no > node.no) {
                break;
            }
            temp = temp.next;
        }
        node.next = temp.next;
        temp.next = node;
    }
```



###### 遍历

```
/**
     * 遍历节点
     */
    public void traversal() {
        HeroNode temp = head;
        while (temp.next != null) {
            temp = temp.next;
            System.out.println(temp);
        }
    }
```

###### 更新

```
 /**
     * 根据NO更新结点
     *
     * @param heroNode
     */
    public void update(HeroNode heroNode) {
        Objects.requireNonNull(heroNode);
        HeroNode temp = head;
        while (true) {
            if (temp.next == null) {
                System.out.println("没有找到您要更新的结点");
                return;
            }
            if (temp.next.no == heroNode.no)
                break;
            temp = temp.next;
        }
		
		//统一在这里进行操作
        temp.next.name = heroNode.name;
        temp.next.nickName = heroNode.nickName;
    }
```

###### 删除

```
/**
 * 根据NO删除结点
 *
 * @param no
 */
public void delete(int no) {
    HeroNode temp = head;
    while (true) {
        if (temp.next == null) {
            System.out.println("删除失败,没有找到此节点");
            return;
        }
        if (temp.next.no == no)
            break;
        temp = temp.next;
    }
    temp.next = temp.next.next;
}
```

###### 长度

```
public int size() {
    int len = 0;
    HeroNode temp = head;
    while (temp.next != null) {
        len++;
        temp = temp.next;
    }
    return len;
}
```

###### 倒序查找

```
/**
 * 查找单链表倒数第k个结点
 *
 * @param descIndex k
 * @return
 */
public HeroNode findDesc(int descIndex) {
    int size = size();
    if (descIndex <= 0 || size < descIndex)
        throw new IndexOutOfBoundsException();

    HeroNode temp = head;
    int offSet = size - descIndex;
    while (offSet > 0) {
        temp = temp.next;
        offSet--;
    }

    return temp.next;
}
```

###### 反转

```
 /**
     * 反转单链表
     * 思路,创建一个新的头,从旧的头里遍历,如果不为空,那么就插入到新头的下一个结点,最后再
     * 把旧的头的下一个结点指向新的头的下一个结点,实现反转
     */
    public void reverse() {
        int size = size();
        if (size <= 1) {
            System.out.println("无需反转");
            return;
        }

        HeroNode newHead = new HeroNode();
/*        HeroNode curNode = head.next;
        while (curNode != null) {
            HeroNode temp = curNode;
            curNode = curNode.next;
            temp.next = newHead.next;
            newHead.next = temp;
        }*/

        HeroNode temp = this.head;
        while (temp.next != null) {
            HeroNode cache = temp.next;
            temp.next = temp.next.next;
            cache.next = newHead.next;
            newHead.next = cache;
        }

        this.head.next = newHead.next;
    }
```



###### 反向打印

```
/**
 * 反向打印单链表,方式2,栈
 */
public void reverseTraversal2(HeroNode node) {
    Objects.requireNonNull(node);
    if (node.next != null) {
        node = node.next;
        reverseTraversal2(node);
        System.out.println(node);
    }
}

 /**
     * 反向打印,方法1,反向遍历
     */
    public void reverseTraversal1() {
        reverse();
        traversal();
        reverse();
    }
```



###### 合并

```
/**
 * 合并两个有序的单链表，要求合并后还是有序的
 *
 * @param other 另一个单链表
 * @return
 */
public SingleLinkedList merge(SingleLinkedList other) {
    Objects.requireNonNull(other);
    /**
     * 这里将辅助结点设置为头结点的下一个结点,目的是为了下面的while循环直接判断此节点是否为空
     *  如果设置成头结点的话,那么下面就会有问题
     */
    HeroNode temp = other.head.next;
    while (temp != null) {
        //缓存下此节点的下一个节点,因为此节点排序后的next肯定不是原来的next,所以要缓存一下,以便后面的遍历
        HeroNode cache = temp.next;
        addAndSort(temp);
        temp = cache;
    }

    return this;
}
```

###### Demo

```
 public static void main(String[] args) throws InterruptedException {
        HeroNode h1 = new HeroNode(1, "宋江", "呼保义");
        HeroNode h2 = new HeroNode(2, "卢俊义", "玉麒麟");
        HeroNode h3 = new HeroNode(3, "吴用", "智多星");
        HeroNode h4 = new HeroNode(4, "公孙胜", "入云龙");
        HeroNode h5 = new HeroNode(5, "关胜", "大刀");

        SingleLinkedList s = new SingleLinkedList();
        s.addAndSort(h5);
        s.addAndSort(h4);
        s.addAndSort(h3);
        s.addAndSort(h2);
        s.addAndSort(h1);

        SingleLinkedList s2 = new SingleLinkedList();
        HeroNode h6 = new HeroNode(6, "林冲", " 豹子头");
        HeroNode h7 = new HeroNode(7, "秦明", "霹雳火");
        HeroNode h8 = new HeroNode(8, "呼延灼", "双鞭");
        HeroNode h9 = new HeroNode(9, "花荣", "小李广");
        HeroNode h10 = new HeroNode(10, "柴进", "小旋风");

        s2.addAndSort(h6);
        s2.addAndSort(h7);
        s2.addAndSort(h8);
        s2.addAndSort(h9);
        s2.addAndSort(h10);


        s.merge(s2);
        s.traversal();
    }
```



##### 双向链表

​	可以从后往前遍历

​	可以实现自我删除

```
public class DoublyLinkedList<E> {

    transient Node<E> head = new Node<>(null);
    transient Node<E> tail = new Node<>(null);
    private int size;
        static class Node<E> {
            E e;
            Node<E> prev;
            Node<E> next;


            Node(E e) {
                this.e = e;
            }
        }
    }
```



###### add

```
    /**
     * 加在tail的前面
     *
     * @param e
     */
    public void add(E e) {
        Objects.requireNonNull(e);
        Node<E> node = new Node<>(e);
        node.prev = tail.prev;
        tail.prev.next = node;
        tail.prev = node;
        node.next = tail;
        size++;
    }
```

###### remove

```
 public boolean remove(E e) {
        Objects.requireNonNull(e);
        Node temp = head;
        while (temp.next != null) {
            if (e.equals(head.next.e)) {
                remove0(head.next);
                return true;
            }
            temp = temp.next;
        }
        return false;
    }

    private void remove0(Node<E> e) {
        Objects.requireNonNull(e);
        Node<E> prev = e.prev;
        Node<E> next = e.next;

        prev.next = next;
        next.prev = prev;

        size--;
    }
```

###### traverse

```
    public void traverse() {
        Node<E> temp = head;
        while (temp.next != null) {
            if (temp.next == tail)
                return;
            System.out.println(temp.next.e);
            temp = temp.next;
        }
    }
```

###### size

```
    public int size() {
        return size;
    }
```



##### 单向环形链表

​	解决约瑟夫问题

```
package com.chuquwan.linkedlist;

import java.util.ArrayList;
import java.util.Objects;

public class RingLinkedList<E> {

    public RingLinkedList() {
        head.next = head;
    }

    private Node<E> head = new Node<>(null);
    private int size;

    /**
     * 插入节点至环形链表尾部，并将尾部节点的next指向头结点
     *
     * @param e
     */
    public void add(E e) {
        Objects.requireNonNull(e);
        Node<E> node = new Node<>(e);

        Node<E> temp = head;
        while (true) {
            if (temp.next == head)
                break;
            temp = temp.next;
        }

        temp.next = node;
        node.next = head;

        size++;
    }

    public void remove(E e) {
        Objects.requireNonNull(e);

        Node<E> temp = head;
        while (true) {
            if (temp.next == head) {
                System.out.println("没有结点可以删除");
                return;
            }
            if (temp.next.e.equals(e))
                break;
            temp = temp.next;
        }

        temp.next = temp.next.next;
        size--;
    }

    /**
     * 此方法下标从0开始
     * @param e
     * @return
     */
    public int indexOf(E e) {
        Objects.requireNonNull(e);

        int count = 0;
        Node<E> temp = head;
        while (true) {
            if (temp.next == head)
                return -1;
            if (temp.next.e.equals(e))
                return count;
            count++;
            temp = temp.next;
        }
    }

    /**
     * index从1开始,index为n就代表取出第n个
     * @param index
     * @return
     */
    public Node<E> get(int index) {
        if (index < 1 || index > size)
            throw new IndexOutOfBoundsException();
        int count = 0;
        Node temp = head;
        while (count < index) {
            temp = temp.next;
            count++;
        }
        return temp;
    }

    /**
     * 约瑟夫问题的解决方案
     *
     * @param beginIndex 从第几个开始 >=1
     * @param quantity   一次数几个  >=1
     */
    public void solution(int beginIndex, int quantity) {
        if (beginIndex < 1 || quantity < 1)
            return;
        //beginIndex==3就得到第3个元素
        Node<E> node = get(beginIndex);

        int count = quantity;
        while (count > 0) {
            node = node.next;
            if (node == head)
                node = node.next;
            count--;
        }

        Node<E> nextBeginNode = node.next;
        if (nextBeginNode == head)
            nextBeginNode = head.next;
        System.out.println(node.e);
        remove(node.e);
        solution(indexOf(nextBeginNode.e) + 1, quantity);
    }

    static class Node<E> {
        E e;
        Node<E> next;

        public Node(E e) {
            this.e = e;
        }
    }

    public static void main(String[] args) {
        RingLinkedList<Object> r = new RingLinkedList<>();
        r.add("1");
        r.add("2");
        r.add("3");
        r.add("4");
        r.add("5");

        r.solution(1,2);//3 1 5 2 4
    }
}

```



#### Stack

​	**Top**	栈顶，允许插入和删除

​	**Bottom**	栈底，固定的，不能插入和删除

​	最先放入栈中的元素在栈底，最后放入的元素在栈顶

​	栈的应用:

​		子程序的调用，方法栈

​		表达式的转换与求值(中缀转后缀)

​		二叉树的遍历

​		图形的深度优先搜索法

##### ArrayStack

​	内部维护了一个length属性，表示栈的长度

```
public class ArrayStack<E> {
    private int maxLength;
    private Object[] elements;
    private int length = 0;
    //栈顶，初始化为-1
    private int top = -1;

    public ArrayStack(int maxLength) {
        this.maxLength = maxLength;
        this.elements = new Object[maxLength];
    }

    public ArrayStack() {
        this(64);
    }
```

###### pop

```
 /**
     * 弹栈，弹出栈顶元素
     *
     * @return
     */
    public E pop() {
        if (isEmpty())
            return null;

        length--;
        return (E) elements[top--];
    }
```

###### push

```
    /**
     * 入栈
     * @param item
     * @return
     */
    public E push(E item) {
        Objects.requireNonNull(item, "item is null");
        if (isFull()) {
            System.out.println("Stack is full");
            return null;
        }
        elements[++top] = item;
        length++;
        return item;
    }
```

###### isEmpty

```
    public boolean isEmpty() {
        return length == 0;
    }
```

###### isFull

```
    public boolean isFull() {
        return length == maxLength;
    }
```





###### 计算器

​	思路

​		计算中缀表达式的计算器

​		3+2*5

​		初始化两个栈，操作数栈和操作符栈

​		从左到右遍历表达式，如果是数字就压入操作数栈，如果是操作符则有下面的情况:

​			如果操作符栈为空，那么就将操作符压入操作符栈

​			如果操作符栈不为空，那么比较此操作符和栈中的栈顶操作符优先级，如果比栈中的优先级大，那么就压入栈顶，如果小于等于栈中的优先级，说明栈中的操作符优先级大，需要先执行，就弹出此操作符栈中的栈顶操作符和操作数栈中的两个数进行运算(注意操作数栈中弹出的的俩数的运算顺序)，将结果压入操作数栈，并将新的操作符压入操作符栈的栈顶

​			最后将操作符栈中的操作符依次弹出和操作数栈进行运算，最后操作数栈中只有一个数就是结果

```
 public static void main(String[] args) {
        String e = "111+222+333";
        System.out.println(calculator(e));  //666
    }

	//将传入的表达式转成字符串数组
    private static Object[] toArray(String expresion) {
        ArrayList<String> strings = new ArrayList<>();
        int beginIndex = 0;
        int length = expresion.length();
        for (int i = 0; i < length; i++) {
            if (isOp(expresion.charAt(i))) {
                strings.add(expresion.substring(beginIndex, i));
                strings.add(expresion.charAt(i) + "");
                if (expresion.substring(i + 1).matches("^\\d+$")) {
                    strings.add(expresion.substring(i + 1, length));
                    break;
                }
                beginIndex = i + 1;
            }
        }

        return strings.toArray();
    }

	//判断是否是操作符
    private static boolean isOp(char c) {
        switch (c) {
            case '+':
            case '-':
            case '*':
            case '/':
                break;
            default:
                return false;
        }
        return true;
    }
	
    public static Integer calculator(String expresion) {
        Objects.requireNonNull(expresion);
        //正则表达式这里耗时较多
        String reg = "^\\d+([+|-|*|/]\\d+)+";
        if (!expresion.matches(reg)) {
            throw new RuntimeException("invalid expresion");
        }
        Object[] cs = toArray(expresion);
        ArrayStack<Integer> num = new ArrayStack<>(10);
        ArrayStack<String> op = new ArrayStack<>(10);

        for (Object s1 : cs) {
            String s = (String) s1;
            if (s.matches("\\d+"))
            	//如果此字符串是数字的话，就压入操作数栈
                num.push(Integer.valueOf(s));
            else {
            	//是操作符，那么就先判断操作数栈是否为空
                if (!op.isEmpty()) {
                	//不为空
                	//判断此操作符和栈顶操作符的优先级
                    if (Precedences.calculatorPrecedence(s) <= Precedences.calculatorPrecedence((String) op.elements[op.top])) {
                    	//此操作符优先级小于栈顶优先级，将栈顶操作符弹出并运算
                        int num1 = num.pop();
                        int num2 = num.pop();
                        String o = op.pop();
                        int num3 = calculation(num2, num1, o);
                        num.push(num3);
                    }
                }
                //将操作符压入栈顶
                op.push(s);
            }
        }
		//进行最后遍历操作符栈进行收尾工作
        while (op.length > 0) {
            Integer n1 = num.pop();
            Integer n2 = num.pop();
            num.push(calculation(n2, n1, op.pop()));
        }

        return num.pop();
    }

	//计算的方法
    private static Integer calculation(int num1, int num2, String op) {
        Integer ret;
        switch (op) {
            case "+":
                ret = num1 + num2;
                break;
            case "-":
                ret = num1 - num2;
                break;
            case "*":
                ret = num1 * num2;
                break;
            case "/":
                ret = num1 / num2;
                break;
            default:
                ret = null;
        }
        return ret;
    }

}

//优先级类
class Precedences {
    //加
    private static final int OP_ADD = 1;
    //减
    private static final int OP_SUB = 1;
    //乘
    private static final int OP_MUL = 2;
    //除
    private static final int OP_DIV = 2;

	//判断优先级的方法
    public static int calculatorPrecedence(String op) {
        switch (op) {
            case "+":
                return OP_ADD;
            case "-":
                return OP_SUB;
            case "*":
                return OP_MUL;
            case "/":
                return OP_DIV;
            default:
                return -1;
        }
    }
```

###### 中缀转前缀

​	前缀表达式又叫波兰表达式，，操作符在操作数的前面

​	1*3+5的前缀表达式是	+\*135

​	**前缀表达式计算时，从后往前遍历字符串，遇到操作数则入栈，遇到操作符则取出操作数栈的头俩元素进行计算，并将结果压入操作数栈栈顶**

​	**如何中缀转前缀**

​		比如1*3+5

​		**逆序遍历**，遇到数字就压入操作数栈，遇到**操作符**有下面的情况:

​			如果操作符栈为空或者栈顶是**右括号**(因为是逆序遍历，所以右括号是括号的开始)，那么就直接将**操作符**压入操作符栈

​			如果不为空，就拿操作符栈顶元素和**操作符**进行比较，如果栈顶元素优先级大，且栈顶元素不是**左右括号**，则将栈顶元素弹出并压入操作数栈，如果栈顶元素优先级小，则将**操作符**压入操作符栈，并继续遍历

​			如果栈顶元素是**左括号**，那么就将栈顶元素一直pop出来，直到它匹配的右括号也被pop出来为止，并将操作符压入操作符栈栈顶

​			最后将操作符栈中的元素都出栈并压入操作数栈，**并将操作数栈正序遍历并拼接字符串**（意思就是栈的栈顶为字符串头，栈的出栈顺序就是字符串的拼接顺序），就是最终的前缀表达式



**核心方法**

```
    /**
     * 中缀转前缀
     *
     * @param expresion
     * @return
     */
    public static List<String> inFixToPreFix(String expresion) {
        Objects.requireNonNull(expresion);
        //这里就不判断表达式是否有效了
        //1.将表达式拆分成字符串数组
        String[] resolve = ExpresionUtils.resolve(expresion);
        //2.初始化两个栈，操作数栈和操作符栈
        ArrayStack<String> nums = new ArrayStack<>(20);
        ArrayStack<String> ops = new ArrayStack<>(20);
        //3.逆序遍历解析后的数组，将其加入栈
        int len = resolve.length;
        for (int i = len; i > 0; i--) {
            //3.1判断s是否为运算符
            if (ExpresionUtils.isOp(resolve[i - 1])) {
                //3.1.1是运算符
                //3.1.2判断操作符栈是否为空，如果为空，将其操作符直接压入操作符栈
                if (!ops.isEmpty()) {
                    //不为空，判断栈顶元素和此操作符的优先级
                    if (Precedences.calculatorPrecedence(ops.peek()) > Precedences.calculatorPrecedence(resolve[i - 1])) {
                        //如果栈顶元素的优先级大于此操作符，那么就将栈顶元素弹出，将其压入到操作数栈中
                        if (ops.peek().equals("(")) {
                            while (!ops.peek().equals(")"))
                                nums.push(ops.pop());
                            nums.push(ops.pop());//为啥再pop一次呢?因为上面的右括号还没pop出来
                        } else if (!ops.peek().equals(")"))
                            nums.push(ops.pop());
                    }
                }
                ops.push(resolve[i - 1]);
            } else {
                //3.2是数字，直接加入操作数栈
                nums.push(resolve[i - 1]);
            }
        }

        while (!ops.isEmpty()) {
            nums.push(ops.pop());
        }

        //4.最终将操作数栈转为字符串返回
        ArrayList<String> list = new ArrayList<>();
        while (!nums.isEmpty()) {
            if (nums.peek().equals("(") || nums.peek().equals(")")) {
                nums.pop();
                continue;
            }
            list.add(nums.pop());
        }

        return list;
    }
```

**解析字符串为数组**

```
  /**
         * 解析字符串为数组
         *
         * @param expresion
         * @return
         */
        static String[] resolve(String expresion) {
            String exp = expresion.trim();
            ArrayList<String> list = new ArrayList<>();

            int beginIndex = 0;
            int len = exp.length();
            for (int i = 0; i < len; i++) {
                if (isOp(exp.charAt(i) + "")) {
                    if (beginIndex != i)
                        list.add(exp.substring(beginIndex, i));
                    list.add(exp.charAt(i) + "");
                    beginIndex = i + 1;
                }
            }

            if (beginIndex != len)
                list.add(exp.substring(beginIndex));

            String[] ret = new String[list.size()];
            int len2 = 0;
            for (String s : list) {
                ret[len2++] = s;
            }
            return ret;
        }
```

**判断是否为运算符**

```
        /**
         * 判断是否为运算符
         *
         * @param s
         * @return
         */
        static boolean isOp(String s) {
            return s.equals("+") || s.equals("-") || s.equals("*") || s.equals("/") || s.equals("(") || s.equals(")");
        }
```





###### 中缀转后缀	

​	后缀表达式又叫逆波兰表达式，操作符在操作数的后面





#### BST

​	哈希表和二叉排序树的比较

​	<https://blog.csdn.net/qq_31984717/article/details/84873661>

​	Binary Sort(Search) Tree	二叉排序树

​	左节点比根节点小，右节点比根节点大

##### 构造BST

小的放左子树，大的放右子树，这里就不写了

##### 删除结点

​	删除结点有点麻烦，下面一一论述

###### 删除叶子结点

​	删除叶子结点直接删除即可

###### 删除只有一颗子树的结点

​	这种情况，将子树补到待删除节点的位置

###### 删除两棵子树的结点

​	此情况，找到右子树中最小的节点或者左子树中最大的结点替换待删除结点的父亲节点

​	因为要找到适中的结点



#### AVL树

​	是为了解决BST树太长的问题(左子树远远长于右子树或相反)，导致搜索效率急速下降

​	首先AVL树一定是BST树，只不过是在较长的BST数进行了旋转(换一个结点当根)，将其平衡

​	AVL树是空树或者左右子树高度差绝对值不超过1

​	AVL树的左右子树也是AVL树

​	

​	所以说呢，我认为将BST数转换为AVL数的关键就是找到这个新root

​	**当有新节点插入时，如果插入这个结点后的右子树(或左子树)的高度大于左子树(或右子树)的高度+1，就要将其进行左旋转(右旋转)，达到平衡**



​	![58641734209](F:\360MoveData\Users\dell\Desktop\学习笔记\图片\1586417342093.png)



##### 求左右子树高度

​	递归，类似于0-1背包问题

​	求一个树的高度等于求这个树的左子树的高度与右子树的高度的最大值，以此类推

###### 求左子树高度

```
    public int rightHeight() {
        if (rc == null)
            return 0;
        return rc.height();
    }

    public int height() {
        return Math.max(lc == null ? 0 : lc.height(), rc == null ? 0 : rc.height()) + 1;
    }
```



###### 求右子树的高度

```
    public int height() {
        return Math.max(lc == null ? 0 : lc.height(), rc == null ? 0 : rc.height()) + 1;
    }
    
    public int leftHeight() {
        if (lc == null)
        return 0;
        return lc.height();
    }
```



###### 左旋转

​	右子树高度高于左子树高度+1时旋转

```
    private void rotateLeft() {
        Node replaceRoot = new Node();
        replaceRoot.v = this.v;
        replaceRoot.lc = this.lc;
        replaceRoot.rc = this.rc.lc;

        this.v = this.rc.v;
        this.rc = this.rc.rc;
        this.lc = replaceRoot;
    }
```



###### 右旋转

​	左子树高度高于右子树高度+1时旋转

```
    private void rotateRight() {
        Node replaceRoot = new Node();
        replaceRoot.v = this.v;
        replaceRoot.lc = this.lc.rc;
        replaceRoot.rc = this.rc;

        this.v = this.lc.v;
        this.lc = this.lc.lc;
        this.rc = replaceRoot;
    }
```



###### 双旋转

​	有些情况，旋转一次达不到AVL树

​	比如	{10, 11, 7, 6, 8, 9}

​	导致了以下情况

​		因为7的右子树高于7的左子树，而7要成为新的跟，因此导致右旋转后以7为跟的BST的右子树高度为3，左子树高度为1

​	解决方法：双旋转，在将以10为跟的BST右旋转之前，要先矫正以7位跟的数的右子树太高的情况，将以7为跟的数进行一次左旋转

![58642517433](F:\360MoveData\Users\dell\Desktop\学习笔记\图片\1586425174331.png)





```
        //检查是否超出平衡，如果超出平衡，将其适当旋转，转换为AVL树
        int leftHeight = leftHeight();
        int rightHeight = rightHeight();
        if (Math.abs(leftHeight - rightHeight) > 1) {
            if (leftHeight > rightHeight) {
                //左树高于右树，右旋转
                if (lc != null && lc.leftHeight() < lc.rightHeight()) {
                    lc.rotateLeft();	//左子树先左旋转
                    rotateRight();		//大树再右旋转
                } else {
                    rotateRight();
                }
            } else {
                //左旋转
                if (rc != null && rc.leftHeight() > rc.rightHeight()) {
                    rc.rotateRight();	//以此类推
                    rotateLeft();
                } else {
                    rotateLeft();
                }
            }
        }
```





#### 2-3树

​	`2-3树`是最简单的B树结构，具有如下特点

- ​	2-3树的所有叶子结点都在同一层（只要是B树就满足这个条件）
- ​        2-3树有2结点和3结点，这两个类型的结点要么没有子节点，要么就有满子节点
- ​        2-3树是由2结点树和3节点树构成的



​	`2-3树`构造方法：

  1. 结点依次放入，首先比较根节点

     如果插入的结点比根节点小，判断根节点空间是否已满（是否已有两个值）

     ​	（1）如果不满，将插入的结点的值放置在根节点的左边值（注意，不是左孩子）

     ​	（2）如果已满：

     ​			如果根节点的左孩子不为空，以根节点的左孩子作为根，重复1步骤

     ​			如果根节点的左孩子为空，将目标节点插入到根节点的左孩子处，判断以根节点为根的树是否满足2-3树的特点

     ​				如果满足，此次插入结束

     ​				如果不满足，判断根节点是否已经有了两个值：

     ​					如果只有一个值，把目标节点的值放在根节点的相应位置

     ​					如果两个值都有，那么拆分根节点，把根节点拆分为只有一个值的根节点，此时这个根节点的树已经是2-3树了，然后如果根节点有父节点，判断以父节点为根节点的树是不是2-3树，如果是，继续判断，如果不是，重复上面的步骤

     ​

     如果插入的结点比根节点大，思路跟上面一样



**将[16,24,12,32,14,26,34,10,8,28,38,20]排序成2-3树**

![58659063750](F:\360MoveData\Users\dell\Desktop\学习笔记\图片\1586590637501.png)



#### B树

​	Balance Tree

​	`m阶B树`

​	`m阶`的意思就是此树的`结点`可以拥有`子节点的最大数量`

​	1、根结点至少有两个子女；

​	2、每个非根节点所包含的关键字个数 j 满足：┌m/2┐ - 1 <= j <= m - 1；

​	3、除根结点以外的所有结点（不包括叶子结点）的度数正好是关键字总数加1，故**内部子树**个数 k 满足：┌m/2┐ - 1 <= k <= m ；

┌m/2┐(向上取整)

​	4、所有的叶子结点都位于同一层。

​	



#### Recursion

​	递归

​	解决各种数学问题，八皇后，，汉诺塔，阶乘问题，迷宫问题

​	快速，归并排序，二分查找，分治算法



##### 	阶乘

```
package com.chuquwan.recursion;

/**
 * 阶乘
 */
public class Factorial {
    public static int factorial(int n) {
        if (n == 2)
            return 2;
        return n * factorial(n - 1);
    }
    
    public static void main(String[] args) {
        System.out.println(factorial(5));
    }
}

```



##### n皇后问题

```
package com.chuquwan.recursion;
/**
 * 解决八皇后问题
 * 8*8棋局
 * 8个棋子，不能再同一行，同一列，同一斜线
 * 问多少种摆法
 */
public class EightQueens {
    static int[][] map = new int[8][8];
    static int length = map.length;
    static int count = 0;

    public static void main(String[] args) {
        at(map, 0, 0);
        System.out.println(count);
    }

    /**
     * copy数组，没什么可说的
     *  至于为什么copy，看下面
     * @param original
     * @return
     */
    private static int[][] copy(int[][] original) {
        int[][] ret = new int[length][length];
        for (int i = 0; i < length; i++) {
            for (int j = 0; j < length; j++) {
                ret[i][j] = original[i][j];
            }
        }
        return ret;
    }

    /**
     * 核心方法，会做详解
     * 此方法为递归方法
     * @param currMap   这个是当前棋盘
     * @param x         想要下子的x坐标
     * @param y         想要下子的y坐标
     */
    private static void at(int[][] currMap, int x, int y) {
        /**
         * 为什么循环?
         *  八个子放在8*8的棋盘上，不能在同一行，同一列，同一斜线，所以此8子必定在不同的行
         *  每一个子可以放在他所在的行的任意位置，这就是循环的目的
         */
        for (int i = 0; i < length; i++) {
            /**
             * 为什么copy？
             *  上面说了循环的目的，每一个子可以下在一行中的任意位置(只要没跟其他子在同一行，同一列，同一斜线)
             *  必须保证不同下法的不可见性，我这里采用的方法是给每一种下法都提供一个拷贝过后的数组，这样不同下法之间下子就不会影响其他下法的棋盘
             */
            int[][] cache = copy(currMap);
            /**
             * 判断能不能下这个子，如果不能下的话，就继续循环(不能下的话，当然要看右边的能不能下)
             */
            if (can(currMap, x, y + i)) {
                /**
                 * 给此棋盘下子，1就代表已经下过
                 */
                cache[x][y + i] = 1;
                /**
                 * 递归出口，如果下到了最后一行，就表示8个子已经下完了，那么就return
                 */
                if (x == length - 1) {
                    //给count++
                    count++;
                    return;
                }
                /**
                 * 如果没有下到最后一行，就下下一行的子
                 */
                at(cache, x + 1, y);
                cache = null;
            }
        }
    }

    /**
     * 判断在给定的棋盘上能否在给定的坐标下这个子
     *  就是不能和其他的子在同一行，同一列，同一斜线
     * @param currMap
     * @param x
     * @param y
     * @return
     */
    private static boolean can(int[][] currMap, int x, int y) {
        for (int i = 0; i < length; i++) {
            if (currMap[i][y] == 1)
                return false;
        }
        for (int i = 0; i < length; i++) {
            for (int j = 0; j < length; j++) {
                int ax = Math.abs(i - x);
                int ay = Math.abs(j - y);
                if (ax == ay && currMap[i][j] == 1) {
                    return false;
                }
            }
        }
        return true;
    }

}

```



#### Sort

##### 时间空间复杂度

![58173684020](H:\笔记\images\1581736840206.png)



**注:一以下排序算法计算时间，如不加说明，默认都是在四核八线程cpu上排列随机200000个数据，升序排列**



##### BubbleSort

冒泡排序

**time**:99734ms

```
    public static void sort3(int[] arr) {
        int length = arr.length;
        boolean flag;
        for (int i = 0; i < length - 1; i++) {
            flag = true;
            for (int j = 0; j < length - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    arr[j] = arr[j] ^ arr[j + 1];
                    arr[j + 1] = arr[j] ^ arr[j + 1];
                    arr[j] = arr[j] ^ arr[j + 1];
                    flag = false;
                }
            }
            if (flag)	//最好情况为什么是O(n)呢?因为这里，如果是最好情况，那就是已经排好序了，所以呢，这里会在i=0时就break出去，所以最好情况是o(n)
                break;
        }
    }
```



##### SelectSort

选择排序

从未排序的序列中找到最小的放到已排序的序列的末尾，直至最后一个

不稳定:58529

**time**:14000ms

```
    public static void sort2(int[] arr) {
        int len = arr.length;
        int min;
        int minIndex;
        for (int i = 0; i < len - 1; i++) {
            minIndex = i;
            a = i;
            min = arr[i];
            for (int j = i + 1; j < len; j++) {
                if (min > arr[j]) {
                    min = arr[j];
                    minIndex = j;
                }
            }

            arr[minIndex] = arr[i];
            arr[i] = min;
        }
    }
```



##### InsertSort

###### 直接插入排序

稳定的

将待插入的结点插入到已排序的序列的合适位置

**time**:6655ms

```
    public void sort3(int[] arr) {
        int len = arr.length;
        int iv;
        int a;
        for (int i = 1; i < len; i++) {
            iv = arr[i];
            a = i - 1;
            while (a >= 0 && iv < arr[a]) {
                arr[a + 1] = arr[a];
                a--;
            }

            arr[a + 1] = iv;
        }
    }
```

###### ShellSort

希尔排序

有一个增量的概念，第一次增量为数组长度/2，距离等于增量的两个数为一组，先将有相同增量的数组排序，直至增量为1，就排好了

不稳定的

**time**:37ms

```
public static void sort2(int[] arr) {
        int len = arr.length;
        //增量
        int inc = len / 2;
        int iv;
        int a;
        while (inc != 0) {
            //增量为几就是几组
            for (int i = 0; i < inc; i++) {
                for (int j = i + inc; j < len; j += inc) {
                    a = j - inc;
                    iv = arr[j];
                    while (a >= 0 && iv < arr[a]) {
                        arr[a + 1] = arr[a];
                        a -= inc;
                    }
                    arr[a + inc] = iv;
                }
            }
            inc /= 2;
        }
    }
```





##### QuickSort

​	快速排序

​	填坑，分治

​	**time**:28ms--37ms

​	**2000000time**:

```
    public static void sort(int[] arr, int begin, int end) {
        int front = begin;
        int back = end;
        if (front < back) {
            int t = arr[front];
            while (front < back) {
                while (front < back && arr[back] >= t) {
                    back--;
                }
                arr[front] = arr[back];
                while (front < back && arr[front] <= t) {
                    front++;
                }
                arr[back] = arr[front];
            }
            arr[front] = t;
            sort(arr, begin, front - 1);
            sort(arr, front + 1, end);
        }
    }
```



##### MergeSort

​	归并排序

​	**time**:41ms左右

​	**2000000time**:416ms

```
package com.chuquwan.algorithm.sort;

import java.util.Arrays;

public class MergeSort {
    static int c = 0;

    public static void sort(int[] arr) {
        divide(arr, 0, arr.length - 1);
    }

    /**
     * 先分，再和，合并之前必须保证两个数组是有序的
     * @param arr
     * @param begin
     * @param end
     */
    private static void divide(int[] arr, int begin, int end) {
        if (begin < end) {
            divide(arr, begin, begin + (end - begin) / 2);
            divide(arr, begin + (end - begin) / 2 + 1, end);
        }
        merge(arr, begin, end, begin + (end - begin) / 2);
    }

    /**
     * 把两个有序数组合并成一个有序数组
     * @param arr   原数组
     * @param begin 第一个有序数组的起始位置
     * @param end   第二个有序数组的结束位置
     * @param mid   第一个数组和第二个数组的分界点
     */
    private static void merge(int[] arr, int begin, int end, int mid) {
        int len = end - begin + 1;
        int[] arr0 = new int[len];
        int a1Index = begin;
        int a2Index = mid + 1;
        int count = 0;
        while (a1Index <= mid && a2Index <= end) {
            arr0[count++] = arr[a1Index] < arr[a2Index] ? arr[a1Index++] : arr[a2Index++];
        }
        while (a1Index <= mid) {
            arr0[count++] = arr[a1Index++];
        }
        while (a2Index <= end) {
            arr0[count++] = arr[a2Index++];
        }
        System.arraycopy(arr0, 0, arr, begin, len);
    }
}

```



##### RadixSort

​	基数排序

​	桶排序

​	**time**:23ms

​	**2000000time**:144ms

```
package com.chuquwan.algorithm.sort;

import org.jetbrains.annotations.NotNull;

/**
 * 基数排序
 *  跟桶排序很像
 *  稳定
 * 空间换时间
 */
public class RadixSort {
    public static void main(String[] args) {
        //105%100
    }

    public static void sort(@NotNull int[] arr) {
        int len = arr.length;
        int[][] arr1 = new int[10][len];
        //记录每个桶中的元素个数
        int[] arr2 = new int[10];
        //number是数组中最大数的位数
        int number = getNumber(arr);

        int arrIndex = 0;

        for (int i = 0, m = 1; i < number; i++, m *= 10) {
            for (int j = 0; j < len; j++) {
//                arr[j]%10/1
//                arr[j]%100/10
                int n = arr[j] / m % 10;
                arr1[n][arr2[n]++] = arr[j];
            }
            for (int j = 0; j < 10; j++) {
                for (int k = 0; k < arr2[j]; k++) {
                    arr[arrIndex++] = arr1[j][k];
                }
                arr2[j] = 0;
            }
            arrIndex = 0;
        }
    }

    private static int getNumber(int[] arr) {
        int max = 0;
        for (int i = 0; i < arr.length; i++) {
            if (max < arr[i])
                max = arr[i];
        }
        return ("" + max).length();
    }
}

```



##### HeapSort

​	堆排序

​	**time**:30ms

​	**2000000time**:354ms

```
package com.chuquwan.algorithm.sort;

import java.util.Objects;

/**
 * 堆排序
 */
public class HeapSort {

    /**
     * 堆排序
     *
     * @param arr
     */
    public static void sort(int[] arr) {
        int len = arr.length;
        //len/2-1是完全二叉树的最后一个非叶子结点的索引
        for (int i = len / 2 - 1; i >= 0; i--) {
            makeMaxTop(arr, i, arr.length - 1);
        }

        int temp;
        for (int i = len - 1; i > 0; i--) {
            temp = arr[i];
            arr[i] = arr[0];
            arr[0] = temp;

            //为什么从0开始做大顶堆呢？因为大顶堆的每一个非叶子节点的父节点都是最大值，所以只需从上往下即可
            makeMaxTop(arr, 0, i - 1);
        }
    }

    /**
     * 此方法就是你给我个节点，我把这个节点包括他的子节点(非叶子)都给搞成大顶堆
     * 从上往下，因为我相信下面的结点会先调用这个方法
     *
     * @param arr
     * @param begin
     * @param end
     */
    public static void makeMaxTop(int[] arr, int begin, int end) {
        int l = begin * 2 + 1;
        int c = begin;
        int temp;
        for (; l <= end; c = l, l = l * 2 + 1) {
            if (l < end && arr[l] < arr[l + 1])
                l++;
            //l是左分支最大的，l++是右分支最大的，如果顶部元素比l大，那么顶部元素的子非叶子结点也就不用再整理了
            if (arr[c] >= arr[l])
                break;
            else {
                temp = arr[c];
                arr[c] = arr[l];
                arr[l] = temp;
            }
        }
    }


}

```

