# Linux系统管理



### 启动管理

| 运行级别 |                含义                 |
| :------: | :---------------------------------: |
|    0     |                关机                 |
|    1     |    单用户模式，主要用于系统修复     |
|    2     |   不完全的命令行模式，不含NFS服务   |
|    3     | 完全的命令行模式，标准字符界面(now) |
|    4     |              系统保留               |
|    5     |              图形模式               |
|    6     |               重启动                |



#### runlevel

​	查看系统当前运行级别

```
[root@localhost test]# runlevel 
N 3

N代表进入当前级别前的上一个级别，N就是没有，我直接进入了3级别
3代表当前级别
```

#### init

​	切换系统运行级别

```
init 5
```

​	**/etc/inittab**	文件中保存了系统默认开机的运行级别设置

```
[root@localhost test]# cat /etc/inittab 
# inittab is only used by upstart for the default runlevel.
#
# ADDING OTHER CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.
#
# System initialization is started by /etc/init/rcS.conf
#
# Individual runlevels are started by /etc/init/rc.conf
#
# Ctrl-Alt-Delete is handled by /etc/init/control-alt-delete.conf
#
# Terminal gettys are handled by /etc/init/tty.conf and /etc/init/serial.conf,
# with configuration in /etc/sysconfig/init.
#
# For information on how to write upstart event handlers, or how
# upstart works, see init(5), init(8), and initctl(8).
#
# Default runlevel. The runlevels used are:
#   0 - halt (Do NOT set initdefault to this)
#   1 - Single user mode
#   2 - Multiuser, without NFS (The same as 3, if you do not have networking)
#   3 - Full multiuser mode
#   4 - unused
#   5 - X11
#   6 - reboot (Do NOT set initdefault to this)
# 
id:3:initdefault:

```



##### /etc/rc.d/rc.local

​	**/etc/rc.local**是它的软连接

​	系统会在开机之后登陆之前最后执行此脚本，我们可以将我们想初始化的东西放在这个脚本中

```
[root@localhost test]# cat /etc/rc.d/rc.local 
#!/bin/sh
#
# This script will be executed *after* all the other init scripts.
# You can put your own initialization stuff in here if you don't
# want to do the full Sys V style init stuff.

touch /var/lock/subsys/local

```



#### grub

​	配置文件

​	**/boot/grub/grub.conf**

​	**/boot/grub/menu.list**

​	**/etc/grub.conf**

​	后两个是第一个的软连接



##### /boot/grub/grub.conf

```
[root@localhost tmp]# cat /etc/grub.conf 
# grub.conf generated by anaconda
#
# Note that you do not have to rerun grub after making changes to this file
# NOTICE:  You have a /boot partition.  This means that
#          all kernel and initrd paths are relative to /boot/, eg.
#          root (hd0,0)
#          kernel /vmlinuz-version ro root=/dev/sda5
#          initrd /initrd-[generic-]version.img
#boot=/dev/sda
default=0
timeout=5
splashimage=(hd0,0)/grub/splash.xpm.gz
hiddenmenu
title CentOS 6 (2.6.32-754.el6.x86_64)
	root (hd0,0)
	kernel /vmlinuz-2.6.32-754.el6.x86_64 ro root=UUID=9113c69a-d7f3-4efa-a651-0cc319572ae0 rd_NO_LUKS  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_MD crashkernel=auto LANG=zh_CN.UTF-8 rd_NO_LVM rd_NO_DM rhgb quiet
	initrd /initramfs-2.6.32-754.el6.x86_64.img
	
	

defaut			默认启动的系统，0表示默认启动第一个系统
timeout			开机grub界面延迟，-1表示一直等待用户，0表示没有机会选择，直接默认
splashimage		开机的时候grub界面的背景图片
hiddenmenu		隐藏菜单



title			菜单栏显示这个title
root (hd0,0)	 表示第一块硬盘的第一个分区是根分区
ro				启动过程只读
root=UUIDxxx	指定根文件系统所在位置，fstab查看


```



##### grub加密

​	开机进入grub界面，如果要操作grub界面，就要输入此密码

```
[root@localhost tmp]# grub-md5-crypt 
Password: 
Retype password: 
$1$1kZim0$Lm49ROHTcrppjysKtINsS.


将上面生成的密码加入到/etc/grub.conf配置文件中

# grub.conf generated by anaconda
#
# Note that you do not have to rerun grub after making changes to this file
# NOTICE:  You have a /boot partition.  This means that
#          all kernel and initrd paths are relative to /boot/, eg.
#          root (hd0,0)
#          kernel /vmlinuz-version ro root=/dev/sda5
#          initrd /initrd-[generic-]version.img
#boot=/dev/sda
default=0
timeout=5
#必须加在这里，否则不生效
password --md5 $1$1kZim0$Lm49ROHTcrppjysKtINsS.
splashimage=(hd0,0)/grub/splash.xpm.gz
hiddenmenu
title CentOS 6 (2.6.32-754.el6.x86_64)
#	一旦lock，就只能输入密码才能启动此系统，但是输入密码必须拿到本机，所以不能lock
	lock
	root (hd0,0)
	kernel /vmlinuz-2.6.32-754.el6.x86_64 ro root=UUID=9113c69a-d7f3-4efa-a651-0cc319572ae0 rd_NO_LUKS  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_MD crashkernel=auto LANG=zh_CN.UTF-8 rd_NO_LVM rd_NO_DM rhgb quiet
	initrd /initramfs-2.6.32-754.el6.x86_64.img

```



#### 单用户模式

​	进入grep	按e

```
空格 1 回车		进入单用户模式
再次来到grub界面 按b启动
```





### 服务管理

#### 	Centos6

​	rpm包的服务

​	**开启的服务在/var/lock/subsyc/目录下有相应的文件**

​		独立服务

​		基于xinetd的服务

​	源码包安装的服务

##### 开机自启动

###### chkconfig

​	查看，设置系统服务自启动

​	--list	列出系统服务启动信息，只能列出rpm包安装的独立服务

​	--add	添加服务，多用来添加源码包的服务

​	--del	删除服务

​	chkconfig --level \[系统运行级别\] [服务名] on|off

​		只能设置独立服务

```
chkconfig --level 2345 httpd on
设置httpd服务在2345运行级别上开机自启动

chkconfig httpd on	默认2345运行级别自启动
```



###### /etc/rc.local

​	在此文件中写入脚本命令，系统会在开机时运行此脚本



##### 源码包开机自启

###### 	编辑/etc/rc.local文件



###### 	被服务管理识别

​		让源码包能被service，chkconfig命令识别

```
[root@localhost init.d]# ln -s /usr/local/apache2/bin/apachectl /etc/init.d/apache2
做一个软连接，就可以被service命令所识别，因为service命令是找到/etc/rc.d/init.d下的脚本执行


想要被chkconfig识别，需要编辑启动脚本文件
 #!/bin/sh
 #
 #	2345表示系统2345运行模式下自启动，86是开机第86个服务启动，76是关机第76个服务关闭
 # chkconfig: 2345 86 76
 # description: http service in chuquwan.com
 #
 
 chkconfig --add apache2
 就成功了

```



#### Centos7

​	Systemd

​	unit文件目录:

​		/etc/systemd/system

​		/usr/lib/systemd/system

​		/run/systemd/system

​	unit类型

​		.service后缀名，服务unit

​		.target后缀名，  模拟实现运行级别

​		.device后缀名，定义内核识别的设备

​		.mount后缀名，定义文件系统挂载点

​		.socket后缀名，用于标志进程间通信的socket文件

​		.snapshot后缀名，管理系统快照

​		.swap后缀名，标志交换设备

​		.automount后缀名，文件系统的自动挂载点

​		.path后缀名，用于定义文件系统中一个文件或目录



##### ServiceUnit

![58209196236](H:\笔记\images\1582091962366.png)

![58209224483](H:\笔记\images\1582092244836.png)

##### TargetUnit

![58209382887](H:\笔记\images\1582093828872.png)

```
systemctl isolate graphical.target	切换至图形级别，有超时时间 
```



![58209499382](H:\笔记\images\1582094993828.png)





### 进程管理

##### ps

​	查看系统进程信息

​	-a	显示一个终端的所有进程

​	-u	显示进程的归属用户和内存使用情况

​	-x	显示没有控制终端的进程

```
ps aux
ps -le

都可以
```



```
[root@localhost ~]# ps aux
USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root          1  0.0  0.1  19344  1568 ?        Ss   04:32   0:01 /sbin/init
root          2  0.0  0.0      0     0 ?        S    04:32   0:00 [kthreadd]
root          3  0.0  0.0      0     0 ?        S    04:32   0:00 [migration/0]
root          4  0.0  0.0      0     0 ?        S    04:32   0:00 [ksoftirqd/0]
root          5  0.0  0.0      0     0 ?        S    04:32   0:00 [stopper/0]
root          6  0.0  0.0      0     0 ?        S    04:32   0:00 [watchdog/0]
root          7  0.0  0.0      0     0 ?        S    04:32   0:02 [events/0]
root          8  0.0  0.0      0     0 ?        S    04:32   0:00 [events/0]
root          9  0.0  0.0      0     0 ?        S    04:32   0:00 [events_long/0]
root         10  0.0  0.0      0     0 ?        S    04:32   0:00 [events_power_ef]
root         11  0.0  0.0      0     0 ?        S    04:32   0:00 [cgroup]
root         12  0.0  0.0      0     0 ?        S    04:32   0:00 [khelper]
root         13  0.0  0.0      0     0 ?        S    04:32   0:00 [netns]
root         14  0.0  0.0      0     0 ?        S    04:32   0:00 [async/mgr]
root         15  0.0  0.0      0     0 ?        S    04:32   0:00 [pm]
root         16  0.0  0.0      0     0 ?        S    04:32   0:00 [sync_supers]


USER		用户
PID			进程ID
%CPU		进程CPU占用情况
%MEM		内存占用情况
VSZ			该进程占用的虚拟内存大小，单位是kb
RSS			该进程占用的实际物理内存大小，单位kb
TTY			进程是在哪个终端中运行的	？就是系统直接启动的进程
STAT		状态，如下:
    D 无法中断的休眠状态（通常 IO 的进程）；
    R 正在运行可中在队列中可过行的；
    S 处于休眠状态；
    T 停止或被追踪；
    W 进入内存交换  （从内核2.6开始无效）；
    X 死掉的进程   （基本很少見）；
    Z 僵尸进程；
    < 优先级高的进程
    N 优先级较低的进程
    L 有些页被锁进内存；
    s 进程的领导者（在它之下有子进程）；
    l 多进程的（使用 CLONE_THREAD, 类似 NPTL pthreads）；
    + 位于后台的进程组；	
START		启动时间
TIME		
COMMAND
```



##### top

​	-d	指定几秒刷新

​	-n	指定刷新几次

​	-b	切换批处理模式，可以将全部信息保存到文件中

​	-p	只查看某一进程ID

​	-u	只查看指定用户的进程

​	查看系统的CPU和内存的压力负载情况

```
top - 06:19:15 up  1:46,  3 users,  load average: 0.00, 0.00, 0.00
Tasks: 121 total,   1 running, 120 sleeping,   0 stopped,   0 zombie
Cpu(s):  0.1%us,  0.2%sy,  0.0%ni, 99.4%id,  0.2%wa,  0.0%hi,  0.0%si,  0.0%st
Mem:   1003020k total,   361328k used,   641692k free,    41044k buffers
Swap:  2097148k total,        0k used,  2097148k free,   170628k cached
   PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND 
     1 root      20   0 19344 1568 1240 S  0.0  0.2   0:01.48 init                 
     2 root      20   0     0    0    0 S  0.0  0.0   0:00.00 kthreadd                   
     3 root      RT   0     0    0    0 S  0.0  0.0   0:00.00 migration/0                 
     4 root      20   0     0    0    0 S  0.0  0.0   0:00.00 ksoftirqd/0                      
     5 root      RT   0     0    0    0 S  0.0  0.0   0:00.00 stopper/0                       
     6 root      RT   0     0    0    0 S  0.0  0.0   0:00.00 watchdog/0                         
     7 root      20   0     0    0    0 S  0.0  0.0   0:03.42 events/0                           
     8 root      20   0     0    0    0 S  0.0  0.0   0:00.00 events/0                           
     9 root      20   0     0    0    0 S  0.0  0.0   0:00.00 events_long/0                     
    10 root      20   0     0    0    0 S  0.0  0.0   0:00.00 events_power_ef                   
    11 root      20   0     0    0    0 S  0.0  0.0   0:00.00 cgroup                             
    12 root      20   0     0    0    0 S  0.0  0.0   0:00.00 khelper                           
    13 root      20   0     0    0    0 S  0.0  0.0   0:00.00 netns                             
    14 root      20   0     0    0    0 S  0.0  0.0   0:00.00 async/mgr                         
    15 root      20   0     0    0    0 S  0.0  0.0   0:00.00 pm                                 
    16 root      20   0     0    0    0 S  0.0  0.0   0:00.02 sync_supers                       
    17 root      20   0     0    0    0 S  0.0  0.0   0:00.00 bdi-default                       
    18 root      20   0     0    0    0 S  0.0  0.0   0:00.00 kintegrityd/0   
    
    
    
06:19:15							系统当前时间
up 1:46								系统运行了多长时间
3users								系统当前登录了3个用户
load average: 0.00, 0.00, 0.00		   系统在之前1，5,15分钟内的平均负载，一般没有CPU核数大


如果判定服务器是否稳定
	load average
CPU		99.4%id		系统CPU空闲百分比
MEM		free		空闲内存
Swqp	free		空闲的交换内存

```

在top界面

​	?	进入帮助界面

​	M	内存使用率排序

​	P	CPU排序

​	N	PID排序

​	

##### pstree

​	-p	查看进程id号

​	-u	查看进程的所属用户



##### kill

​	信号的种类有很多

​	-1	重启进程

​	-9	强制杀死进程

​	**kill后面只能加PID**

```
[root@localhost ~]# kill -l
 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
63) SIGRTMAX-1	64) SIGRTMAX	
```

```
kill -9 3332
```



##### killall

​	-i	交互式杀死

​	-I	忽略进程名大小写

​	杀死进程组

​	后面跟进程名

```
killall -9 httpd
```



##### pkill

​	-t	终端号		按照终端号踢出用户

```
pkill -9 -t pts/0
```





### 工作管理



#### 将进程放入后台

​	**通过下面两个方法放入后台的程序当它的当前终端关闭后，此程序也会终止**

##### 	command&

​		将程序放入后台继续执行(vi和top命令放入后台会是停止状态)

##### 	ctrl+z

​		将程序停止后放入后台

##### jobs

​	-l	显示PID

​	查看当前在后台运行的程序

##### bg

​	可以将后台停止的线程在后台结束停止状态并将其在后台运行

```
bg %1		1是工作号，是jobs命令查出来的工作号，百分号可以省略
```

##### fg

​	将后台命令恢复到前台运行

```
fg 3
```





#### 后台任务脱离终端

​	上面的任务都是当前终端关闭后就会被终结的，那么如果我想让一个任务与当前终端无关，当前终端挂了以后，这个任务还能继续执行，以下三个方法



##### /etc/rc.local

​	编辑此脚本，系统会在开机之后，登陆之前运行此脚本

##### 定时任务

##### nohup

```
nohup [命令] &
```





#### 系统资源查看

##### vmstat

​	Report virtual memory statistics

​	查看系统的各个资源情况，比top详细，top好像只能查看memory和CPU的

```
#每1秒查看一次，查看三次
[root@localhost ~]# vmstat 1 3
procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 0  0      0 818776  25296  55108    0    0    57     6   31   48  0  1 99  1  0	
 0  0      0 818720  25296  55108    0    0     0     0   15   16  0  0 100  0  0	
 0  0      0 818720  25296  55108    0    0     0     0   12   12  0  0 100  0  0	
 
 procs:
 	r:				等待运行的进程数，数量越大，系统越繁忙
 	b:				不可被唤醒的进程数量，数量越大，系统越繁忙
 
 memory:
 	swpd:			虚拟内存的使用情况，单位kb
 	free:			空闲的内存容量，kb
 	buff:			缓冲的内存容量，kb
 	cache:			缓存的内存容量，kb
 	
 swap:
 	si:				从磁盘中交换到内存中数据的数量，单位kb
 	so:				内存->磁盘，单位kb，此两个数越大，证明数据要经常在磁盘和内存中交换，性能差
 io:
 	bi:				从块设备读入数据的总量，单位是块
 	bo:				写到块设备的数据的总量，单位是块，此两个数越大，代表系统的IO越繁忙
 	
 system:
 	in:				每秒被中断的进程次数
 	cs:				每秒钟进行的事件切换次数，此两个数越大，代表系统与接口设备的通信繁忙
 	
 cpu:
 	us:				非内核进程消耗CPU运算时间的百分比
 	sy:				内核进程消耗CPU运算时间的百分比
 	id:				空闲CPU的百分比
 	wa:				等待I/O所消耗CPU的百分比
 	st:				被虚拟机所盗用的CPU占比
```



##### dmesg

​	显示开机时内核检测信息，用来查看硬件信息的

```
#	查看CPU的信息
[root@localhost ~]# dmesg | grep CPU		
SMP: Allowing 128 CPUs, 127 hotplug CPUs
NR_CPUS:4096 nr_cpumask_bits:128 nr_cpu_ids:128 nr_node_ids:1
PERCPU: Embedded 33 pages/cpu @ffff880003400000 s104088 r8192 d22888 u262144
CPU: Physical Processor ID: 0
mce: CPU supports 8 MCE banks
CPU0: Intel(R) Core(TM) i5-7300HQ CPU @ 2.50GHz stepping 09
CPUID marked event: 'cpu cycles' unavailable
CPUID marked event: 'instructions' unavailable
CPUID marked event: 'bus cycles' unavailable
CPUID marked event: 'cache references' unavailable
CPUID marked event: 'cache misses' unavailable
CPUID marked event: 'branch instructions' unavailable
CPUID marked event: 'branch misses' unavailable
Brought up 1 CPUs
microcode: CPU0 sig=0x906e9, pf=0x1, revision=0xb4

```



##### free

​	Linux.md中有介绍





#### 定时任务

##### at

​	想要运行at任务，必须开启atd服务

​	at命令只能在未来的某个时间执行一次任务

​	/etc/at.allow		写入此文件的用户可以使用at命令，其他用户不能

​	/etc/at.deny		写入此文件的用户不能使用at命令，其他用户可以

​	如果同时存在at.allow和at.deny文件，那么at.deny文件会被忽略





​	-m	at计划命令执行完之后无论是否有输出，都以邮件形式发给执行at的用户

​	-c	工作号	查看此任务的详细信息

```
[root@localhost lib]# at now +1 minutes
at> echo hello world
#ctrl+d结束
at> <EOT>
job 2 at 2020-02-05 04:09

```

###### at -c

​	查看定时任务的详细信息



###### demo

```
at 20:00 2008-10-1　　在具体时间执行
at now +10min　　在十分钟后执行
at17:00 tomorrow　　明天下午五点执行
at 6:00 pm + 3 days　　在3天后下午6点执行
```



##### atq

​	查询at命令计划的工作

```
[root@localhost lib]# atq
3	2020-02-05 04:16 a root
3是工作号
```



##### crontab

​	**想要运行crontab任务，必须开启crond服务**

​	/etc/cron.allow	白名单文件

​	/etc/cron/deny	黑名单文件

​	a cron job	定时任务

~~~
格式:	* * * * *	+命令

第一个:代表每小时的第几分钟(0,59)
第二个:代表每天的第几个小时(0,23)
第三个:代表每月的第几天(1,31)
第四个:代表每年的第几个月(1,12)
第五个:每周的第几天(0-7	0，7都代表星期日)

45 22 * * *		每天的22:45执行
0 17 * * 1		每周1的17:00执行
0 5 1,15 * *	每月的1号和15号凌晨5:00执行
40 4 * * 1-5	每周1-5的4:40执行
*/10 4 * * *	每天的四点，每隔十分钟执行一次
0 0 1,15 * 1	每月的1号和15号，每周1的0:0分都会执行
10:3:10:3:*
~~~



###### 命令方式

​	-e	编辑定时任务

​	-r	删除当前用户所有的定时任务，如果要删除一个呢？直接-e编辑文件全删掉不就行了

​	-l	查看定时任务

​	-u	用户名	修改或删除其他用户的定时任务

​	**使用命令方式执行任务，任务的执行身份只能是当前用户的身份，而使用配置文件可以选择身份**



###### 配置文件方式

​	/etc/crontab



​	**/etc/cron.daily**		把脚本放入此目录中，每天执行一次

​	**/etc/cron.hourly**		每小时执行一次

​	**/etc/cron.monthly**	每月执行一次

​	**/etc/cron.weekly**		每周执行一次



以前5版本的时候上面的目录是由/etc/ctontab配置文件执行的，到了6以后就由anacron来执行



##### anacron

​	解决服务器关机时定时任务没有按时执行的问题

​	/var/spool/anacron目录里有一些文件

```
[root@localhost anacron]# pwd
/var/spool/anacron
[root@localhost anacron]# ls
cron.daily  cron.monthly  cron.weekly

这些文件记录了时间，会与当前时间对比，如果超过了定时的时间，也就是说定时任务没有按时执行，那么就会补上
```



​	/etc/anacrontab	

​		anacron的配置文件

```
[root@localhost anacron]# cat /etc/anacrontab 
# /etc/anacrontab: configuration file for anacron

# See anacron(8) and anacrontab(5) for details.

SHELL=/bin/sh
PATH=/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=root
# the maximal random delay added to the base delay of the jobs
RANDOM_DELAY=45
#最大随机延迟
# the jobs will be started during the following hours only
START_HOURS_RANGE=3-22
#anacron命令的执行时间是3-22时

#period in days   delay in minutes   job-identifier   command
1		5		cron.daily		nice run-parts /etc/cron.daily
7		25		cron.weekly		nice run-parts /etc/cron.weekly
@monthly 45		cron.monthly		nice run-parts /etc/cron.monthly

第一行表明一旦超过一天没有执行日常任务，就会执行此日常任务，但会晚5分钟执行

```





#### 日志管理

​	只有rpm包安装的程序日志会在/var/log源码包的日志在其安装目录下(自己指定的安装目录)

```
/var/log/message 系统启动后的信息和错误日志，是Red Hat Linux中最常用的日志之一

/var/log/secure 与安全相关的日志信息

/var/log/maillog 与邮件相关的日志信息

/var/log/cron 与定时任务相关的日志信息

/var/log/spooler 与UUCP和news设备相关的日志信息

/var/log/boot.log 守护进程启动和停止相关的日志消息

/var/log/wtmp 该日志文件永久记录每个用户登录、注销及系统的启动、停机的事件

```



##### /etc/rsyslog.conf

​	日志的配置文件

<https://www.cnblogs.com/fanlong0212/articles/10381628.html>

