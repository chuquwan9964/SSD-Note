# 				设计模式

### 七大原则



#### 单一职责原则

​	**S**ingle **R**esponsibility **P**rinciple

​	一个类只负责一项职责

​	提高类的可读性，可维护性

​	降低类变更而引起的风险

##### 方法级别

​	就是一个类可能会负责多个职责，但是方法必须是只负责一个职责

​	这个出现在类的方法较少时，如果这几个职责写成几个类就会显得类太多

##### 类级别

​	我们应该尽力去维护类的单一职责原则，一个类只管一件事

​	比如Dao层的类



#### 接口隔离原则

​	**I**nterface **I**solation **P**rinciple

​	客户端不应该依赖它不需要的接口，既一个类对另一个类的依赖应该建立在最小的接口上

```
如果接口过于臃肿，只要接口中出现的方法，不管对依赖于它的类有没有用处，实现类中都必须去实现这些方法，这显然不是好的设计。如果将这个设计修改为符合接口隔离原则，就必须对接口进行拆分。
```



#### 依赖倒转原则

​	**D**ependence **I**nversion **P**rinciple

​	一个字，用接口!!!

​	不管是传参也好，还是定义成员属性，都使用其抽象层

- 高层模块不应该依赖低层模块，两者都应该依赖其抽象
- 抽象不应该依赖细节
- 细节应该依赖抽象

有何好处？

​	采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。



#### 里氏替换原则

​	**L**iskov **S**ubstitution **P**rinciple

​	说白了，就是子类尽量不要重写父类的方法，你可以拓展方法，但不要覆盖

​	**里氏替换原则**最早是由*Barbara* *Liskov*在1987年*OOPSLA*上提出的。她指出:“若对每个类型**S**的对象**o1**，都存在一个类型**T**的对象**o2**，使得在所有针对**T**编写的程序**P**中，用**o1**替换**o2**后，程序**P**的行为不变，则**S**是**T**的子类型。”

​	一个软件实体如果适用一个父类的话，那一定适用于其子类，所有引用父类的方法必须能透明地使用其子类的对象，子类对象能够替换父类对象，而程序逻辑不变。



#### 开闭原则

​	**O**pen **C**losed **P**rinciple

​	对应用的拓展开放，对修改关闭

​	简单来说，就是拓展功能时，不能让客户端的代码发生更改，而是服务端的代码进行拓展

#### 迪米特法则

​	**L**aw **o**f **D**emeter

​	最少知识原则（Least Knowledge Principle 简写LKP），就是说一个对象应当对其他对象有尽可能少的了解,不和陌生人说话

​	尽量只调用成员属性，方法参数

​	我只关心调用，而不关心实现，实现由"朋友"来实现

#### 合成复用原则

​	**C**omposite **R**euse **P**rinciple

​	原则是尽量使用合成/聚合的方式，而不使用继承

​	

### 23种设计模式



#### 责任链模式



